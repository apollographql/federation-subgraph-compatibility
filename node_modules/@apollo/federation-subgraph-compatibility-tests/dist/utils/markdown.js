"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSimplifiedMarkdown = exports.generateMarkdown = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const testRunner_1 = require("../testRunner");
const mustache_1 = __importDefault(require("mustache"));
const template = `
The following open-source GraphQL server libraries and other solutions support acting as a subgraph in a federated supergraph.

## Table Legend

| Icon | Description                                          |
| ---- | ---------------------------------------------------- |
| {{{apolloIcon}}} | Maintained by Apollo |
| üü¢    | Functionality is supported                           |
| ‚ùå    | Critical functionality is NOT supported              |
| üî≤    | Additional federation functionality is NOT supported |

{{#compatibilityResults}}

## {{{language}}}

<table>
  <thead>
    <tr>
      <th width="300">Library</th>
      <th>Federation 1 Support</th>
      <th>Federation 2 Support</th>
    </tr>
  </thead>
	<tbody>
    {{#implementations}}
		<tr>
			<th colspan="3"><big><a href="{{{documentation}}}">{{name}}</a></big></th>
		</tr>
		<tr>
			<td>{{description}}<br/>
<br/>
{{#repository}}
Github: <a href="{{{link}}}">{{{name}}}{{#apolloIcon}}&nbsp;&nbsp;{{{apolloIcon}}}{{/apolloIcon}}</a><br/>
<br/>
{{#type}}Type: {{{type}}}<br/>{{/type}}
{{#stargazerCount}}Stars: {{stargazerCount}} ‚≠ê<br/>{{/stargazerCount}}
{{#lastRelease}}Last Release: {{lastRelease}}<br/>{{/lastRelease}}
{{/repository}}
<br/>
{{#coreLibrary}}
Core Library: <a href="{{{link}}}">{{{name}}}{{#apolloIcon}}&nbsp;&nbsp;{{{apolloIcon}}}{{/apolloIcon}}</a><br/>
{{/coreLibrary}}
{{#federationLibrary}}
Federation Library: <a href="{{{link}}}">{{{name}}}{{#apolloIcon}}&nbsp;&nbsp;{{{apolloIcon}}}{{/apolloIcon}}</a>
{{/federationLibrary}}
      </td>
      {{#compatibilities}}
      <td>
        <table>
        {{#tests}}
          <tr><th><code>{{name}}</code></th><td>{{result}}</td></tr>
        {{/tests}}
        </table>
      </td>
      {{/compatibilities}}
    </tr>
    {{/implementations}}
  </tbody>
</table>
{{/compatibilityResults}}
`;
const singleImplementationTemplate = `
<table>
	<thead>
		<tr>
			<th>Federation 1 Support</th>
			<th>Federation 2 Support</th>
		</tr>
	</thead>
	<tbody>
    <tr>
      {{#compatibilities}}
      <td>
        <table>
        {{#tests}}
          <tr><th><code>{{name}}</code></th><td>{{result}}</td></tr>
        {{/tests}}
        </table>
      </td>
      {{/compatibilities}}
		</tr>
	</tbody>
</table>
`;
const apolloIcon = '<img style="display:inline-block; height:1em; width:auto;" alt="Maintained by Apollo" src="https://raw.githubusercontent.com/apollographql/apollo-federation-subgraph-compatibility/d7829ef89441c337749bf6538711a642cfa2689c/docs/assets/horizon_logo.png"/>';
const apolloName = 'apollographql';
function generateMarkdown(results) {
    const resultsSortedByLanguage = results.sort((a, b) => {
        if (a.language === b.language)
            return 0;
        // push other solutions to the end
        if (a.language === 'Other Solutions')
            return 1;
        if (b.language === 'Other Solutions')
            return -1;
        return a.language > b.language ? 1 : -1;
    });
    let compatibilityResults = [];
    var current = null;
    var currentLanguage = null;
    resultsSortedByLanguage.forEach((result) => {
        if (currentLanguage !== result.language) {
            if (currentLanguage !== null) {
                compatibilityResults.push(current);
            }
            currentLanguage = result.language;
            current = {
                language: currentLanguage,
                implementations: [],
            };
        }
        let impl = {
            name: result.fullName || result.name,
            documentation: result.documentation,
            description: result.description,
            compatibilities: generateCompatibilityResults(result.tests),
        };
        if (result.repository) {
            const starCount = Number(result.stargazerCount);
            let stars = null;
            if (starCount > 1000) {
                stars = `${(starCount / 1000).toFixed(1)}k`;
            }
            else {
                stars = `${starCount}`;
            }
            const lastReleaseDate = result.lastRelease?.substring(0, 10);
            let repoName = result.repository.owner
                ? `${result.repository.owner}/${result.repository.name}`
                : result.repository.name;
            impl.repository = {
                name: repoName,
                link: result.repository.link,
                apolloIcon: apolloName == result.repository.maintainer ? apolloIcon : null,
                type: result.type,
                stargazerCount: stars,
                lastRelease: lastReleaseDate,
            };
        }
        if (result.coreLibrary) {
            let coreLibraryName = result.coreLibrary.owner
                ? `${result.coreLibrary.owner}/${result.coreLibrary.name}`
                : result.coreLibrary.name;
            impl.coreLibrary = {
                name: coreLibraryName,
                link: result.coreLibrary.link,
                apolloIcon: apolloName == result.coreLibrary.maintainer ? apolloIcon : null,
            };
        }
        if (result.federationLibrary) {
            let fedLibraryName = result.federationLibrary.owner
                ? `${result.federationLibrary.owner}/${result.federationLibrary.name}`
                : result.federationLibrary.name;
            impl.federationLibrary = {
                name: fedLibraryName,
                link: result.federationLibrary.link,
                apolloIcon: apolloName == result.federationLibrary.maintainer ? apolloIcon : null,
            };
        }
        current.implementations.push(impl);
    });
    // push the last results section
    compatibilityResults.push(current);
    var output = mustache_1.default.render(template, {
        compatibilityResults: compatibilityResults,
        apolloIcon: apolloIcon,
    });
    (0, fs_1.writeFileSync)((0, path_1.resolve)(process.cwd(), 'results.md'), output, 'utf-8');
}
exports.generateMarkdown = generateMarkdown;
function generateSimplifiedMarkdown(results, outputFile) {
    let compatibilityResults = generateCompatibilityResults(results);
    var output = mustache_1.default.render(singleImplementationTemplate, {
        compatibilities: compatibilityResults,
    });
    (0, fs_1.writeFileSync)(outputFile, output, 'utf-8');
}
exports.generateSimplifiedMarkdown = generateSimplifiedMarkdown;
function generateCompatibilityResults(results) {
    let compatibilities = [
        {
            version: 1,
            tests: [],
        },
        {
            version: 2,
            tests: [],
        },
    ];
    testRunner_1.TESTS.forEach((test) => {
        let index = test.fedVersion - 1;
        let testResult = results[test.assertion]?.success
            ? 'üü¢'
            : test.required
                ? '‚ùå'
                : 'üî≤';
        compatibilities[index].tests.push({
            name: test.column,
            result: testResult,
        });
    });
    return compatibilities;
}
//# sourceMappingURL=markdown.js.map