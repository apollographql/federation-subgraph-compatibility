"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareSchemas = void 0;
const fs_1 = require("fs");
const graphql_1 = require("graphql");
const path_1 = require("path");
const productsRaw = (0, fs_1.readFileSync)((0, path_1.resolve)(__dirname, '../../products.graphql'), 'utf-8');
const productsReferenceSchema = (0, graphql_1.parse)(productsRaw);
function findObjectTypeDefinition(document, typeName) {
    return document.definitions.find((d) => d.kind == 'ObjectTypeDefinition' && d.name.value === typeName);
}
function findObjectTypeExtensionDefinition(document, typeName) {
    return document.definitions.find((d) => d.kind == 'ObjectTypeExtension' && d.name.value === typeName);
}
function findObjectTypeExtensionDefinitions(document, typeName) {
    return document.definitions
        .filter((d) => d.kind == 'ObjectTypeExtension' && d.name.value === typeName)
        .map((value) => value);
}
function isListReturnType(type) {
    return type?.kind === 'ListType';
}
function isNonNullReturnType(type) {
    return type?.kind === 'NonNullType';
}
function unwrapReturnType(type) {
    if (isNonNullReturnType(type)) {
        return unwrapReturnType(type.type);
    }
    else if (isListReturnType(type)) {
        return unwrapReturnType(type.type);
    }
    else {
        return type?.name?.value;
    }
}
function compareType(typeName, actualType, expectedType) {
    let errors = '';
    if (actualType === null || actualType === undefined) {
        errors += `\n * target schema does not define ${typeName} type`;
    }
    else {
        errors += compareTypeFields(typeName, actualType.fields, expectedType.fields);
    }
    return errors;
}
function compareTypeFields(typeName, fields, expectedFields) {
    let errors = '';
    expectedFields.forEach((expectedField) => {
        const matchedField = fields.find((f) => f.name.value == expectedField.name.value);
        if (matchedField === null || matchedField === undefined) {
            errors += `\n * ${typeName} type does not declare ${expectedField.name.value} field`;
        }
        else {
            errors += compareNode(typeName, expectedField.name.value, matchedField.type, expectedField.type);
            if (expectedField.arguments) {
                if (!matchedField.arguments) {
                    errors += `\n * ${typeName} does not define arguments on ${expectedField.name.value}`;
                }
                errors += compareArguments(expectedField.name.value, matchedField.arguments, expectedField.arguments);
            }
        }
    });
    return errors;
}
function compareNode(parentType, fieldName, actual, expected) {
    let errors = '';
    const expectedNonNullable = isNonNullReturnType(expected);
    if (isNonNullReturnType(actual) === expectedNonNullable) {
        if (expectedNonNullable) {
            errors += compareNode(parentType, fieldName, actual.type, expected.type);
            return errors;
        }
    }
    else if (expectedNonNullable) {
        errors += `\n * ${parentType} defines different nullability for ${fieldName} field, expected non-nullable but was nullable`;
        errors += compareNode(parentType, fieldName, actual, expected.type);
        return errors;
    }
    else {
        errors += `\n * ${parentType} defines different nullability for ${fieldName} field, expected nullable but was non-nullable`;
        errors += compareNode(parentType, fieldName, actual.type, expected);
        return errors;
    }
    const expectedListReturnType = isListReturnType(expected);
    if (isListReturnType(actual) === expectedListReturnType) {
        if (expectedListReturnType) {
            errors += compareNode(parentType, fieldName, actual.type, expected.type);
            return errors;
        }
    }
    else if (expectedListReturnType) {
        errors += `\n * ${parentType} defines different return type for ${fieldName} field, was expecting a list return type`;
        errors += compareNode(parentType, fieldName, actual, expected.type);
        return errors;
    }
    else {
        errors += `\n * ${parentType} defines different return type for ${fieldName} field, did not expect a list return type`;
        errors += compareNode(parentType, fieldName, actual.type, expected);
        return errors;
    }
    if (unwrapReturnType(actual) !== unwrapReturnType(expected)) {
        errors += `\n * ${parentType} defines different return type for ${fieldName} field, expected ${unwrapReturnType(expected)} but was ${unwrapReturnType(actual)}`;
    }
    return errors;
}
function compareArguments(fieldName, actual, expected) {
    let errors = '';
    expected.forEach((expectedArg) => {
        const matchedArg = actual.find((arg) => arg.name.value == expectedArg.name.value);
        if (matchedArg === null || matchedArg === undefined) {
            errors += `\n * ${fieldName} type does not declare ${expectedArg.name.value} argument`;
        }
        else {
            errors += compareNode(fieldName, expectedArg.name.value, matchedArg.type, expectedArg.type);
        }
    });
    return errors;
}
function compareSchemas(schemaToCompare) {
    const schemaDefinition = (0, graphql_1.parse)(schemaToCompare);
    let errors = '';
    const typesToCompare = [
        'CaseStudy',
        'DeprecatedProduct',
        'Product',
        'ProductDimension',
        'ProductResearch',
        'ProductVariation',
    ];
    typesToCompare.forEach((typeName) => {
        const expectedDefinition = findObjectTypeDefinition(productsReferenceSchema, typeName);
        const actualDefinition = findObjectTypeDefinition(schemaDefinition, typeName);
        errors += compareType(typeName, actualDefinition, expectedDefinition);
    });
    // compare User type extension
    const expectedUserExtensionDefinition = findObjectTypeExtensionDefinition(productsReferenceSchema, 'User') ??
        findObjectTypeDefinition(productsReferenceSchema, 'User');
    const actualUserExtensionDefinition = findObjectTypeExtensionDefinition(schemaDefinition, 'User') ??
        findObjectTypeDefinition(schemaDefinition, 'User');
    errors += compareType('User', actualUserExtensionDefinition, expectedUserExtensionDefinition);
    // compare query fields
    const expectedQueryDefinition = findObjectTypeExtensionDefinition(productsReferenceSchema, 'Query') ??
        findObjectTypeDefinition(productsReferenceSchema, 'Query');
    const allFields = findObjectTypeExtensionDefinitions(schemaDefinition, 'Query')
        .map((value) => value.fields ?? [])
        .flat()
        .concat(findObjectTypeDefinition(schemaDefinition, 'Query')?.fields ?? []);
    const queryFields = allFields.filter((field) => {
        return ['product', 'deprecatedProduct'].includes(field.name.value);
    });
    errors += compareTypeFields('Query', queryFields, expectedQueryDefinition.fields);
    expect(errors).toBe('');
    return true;
}
exports.compareSchemas = compareSchemas;
//# sourceMappingURL=schemaComparison.js.map