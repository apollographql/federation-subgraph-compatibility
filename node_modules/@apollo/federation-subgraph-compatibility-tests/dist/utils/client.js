"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.healthcheck = exports.healthcheckRouter = exports.healthcheckSupergraph = exports.routerRequest = exports.productsRequest = exports.graphqlRequest = exports.ROUTER_URL = void 0;
const make_fetch_happen_1 = __importDefault(require("make-fetch-happen"));
const logging_1 = require("./logging");
exports.ROUTER_URL = 'http://localhost:4000/';
const PING_QUERY = 'query { __typename }';
const ROUTER_HEALTH_URL = 'http://localhost:8088/health';
const PRODUCTS_URL = process.env['PRODUCTS_URL'] ?? 'http://localhost:4001/';
const INVENTORY_URL = 'http://localhost:4003/';
const USERS_URL = 'http://localhost:4002/';
async function graphqlRequest(url, req, headers) {
    const resp = await (0, make_fetch_happen_1.default)(url, {
        headers: {
            accept: 'application/json', // required because Yoga's default content-type is `application/graphql-response+json` as per the spec
            'content-type': 'application/json',
            ...(headers ?? {}),
        },
        method: 'POST',
        body: JSON.stringify(req),
    });
    if (resp.ok &&
        resp.headers.get('content-type')?.startsWith('application/json')) {
        return resp.json();
    }
    return resp.text();
}
exports.graphqlRequest = graphqlRequest;
function productsRequest(req, headers) {
    return graphqlRequest(PRODUCTS_URL, req, headers);
}
exports.productsRequest = productsRequest;
function routerRequest(req, headers) {
    return graphqlRequest(exports.ROUTER_URL, req, headers);
}
exports.routerRequest = routerRequest;
async function healthcheckSupergraph(url) {
    const routerUp = await healthcheckRouter();
    const inventoryUpPromise = healthcheck('inventory', INVENTORY_URL);
    const usersUpPromise = healthcheck('users', USERS_URL);
    const productsUpPromise = healthcheck('products', url);
    return (routerUp &&
        (await inventoryUpPromise) &&
        (await usersUpPromise) &&
        (await productsUpPromise));
}
exports.healthcheckSupergraph = healthcheckSupergraph;
async function healthcheckRouter() {
    (0, logging_1.infoLog)('health check - router', ROUTER_HEALTH_URL);
    try {
        const routerHealthcheck = await (0, make_fetch_happen_1.default)(ROUTER_HEALTH_URL, {
            retry: { retries: 10, maxTimeout: 1000 },
        });
        if (!routerHealthcheck.ok) {
            console.log('router failed to start');
            return false;
        }
        (0, logging_1.infoLog)('health check - router OK');
        return true;
    }
    catch (err) {
        console.error('router faield to start', err);
        return false;
    }
}
exports.healthcheckRouter = healthcheckRouter;
async function healthcheck(appName, url) {
    let attempts = 100;
    let lastError = null;
    while (attempts--) {
        (0, logging_1.infoLog)(`health check - ${appName}`, url);
        try {
            const subgraphHealthcheck = await graphqlRequest(url, {
                query: PING_QUERY,
            });
            if (subgraphHealthcheck.data?.__typename) {
                (0, logging_1.infoLog)(`health check - ${appName} OK`);
                return true;
            }
            else {
                lastError = subgraphHealthcheck.errors;
            }
        }
        catch (e) {
            lastError = e;
        }
        await new Promise((r) => setTimeout(r, 1000));
    }
    console.log(`${appName} failed to start`);
    console.log(lastError);
    return false;
}
exports.healthcheck = healthcheck;
//# sourceMappingURL=client.js.map