"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startSupergraph = void 0;
const execa_1 = __importDefault(require("execa"));
const debug_1 = __importDefault(require("debug"));
const logging_1 = require("./utils/logging");
const composeSupergraph_1 = require("./composeSupergraph");
const client_1 = require("./utils/client");
const path_1 = require("./utils/path");
const path_2 = require("path");
const promises_1 = require("fs/promises");
const pm2Debug = (0, debug_1.default)('pm2');
const dockerDebug = (0, debug_1.default)('docker');
/**
 * Starts supergraph using PM2 or Docker Compose.
 *
 * @returns shutdown hook for PM2/Docker Compose
 */
async function startSupergraph(config) {
    (0, logging_1.logWithTimestamp)('starting supergraph...');
    if (config.kind === 'docker') {
        return startSupergraphUsingDocker(config);
    }
    else {
        return startSupergraphUsingPm2(config);
    }
}
exports.startSupergraph = startSupergraph;
async function startSupergraphUsingPm2(config) {
    pm2Debug(`\n***********************\nStarting supergraph using PM2...\n***********************\n\n`);
    try {
        // start pm2 daemon to avoid race conditions
        await (0, execa_1.default)('pm2', ['ping']);
        const pm2Logs = (0, execa_1.default)('pm2', ['logs']);
        pm2Logs.stdout.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
        pm2Logs.stderr.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
        let productsSubgraph = null;
        if (config.configFile) {
            productsSubgraph = await startProductsSubgraphUsingPm2(config.configFile);
        }
        const template = await (0, promises_1.readFile)((0, path_2.resolve)(__dirname, '../supergraph-config.js.template'), 'utf-8');
        const supergraphConfig = template.replaceAll('${DIST_DIR}', (0, path_1.normalizePath)((0, path_2.resolve)(__dirname)));
        await (0, promises_1.writeFile)('supergraph.config.js', supergraphConfig);
        const proc = (0, execa_1.default)('pm2', ['start', 'supergraph.config.js']);
        proc.stdout.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
        proc.stderr.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
        if (productsSubgraph != null && productsSubgraph.exitCode !== 0) {
            throw new Error('Products subgraph did not start successfully');
        }
        await proc;
        if (proc.exitCode !== 0) {
            throw new Error('Subgraphs did not start successfully');
        }
        const started = await (0, composeSupergraph_1.composeDevSupergraph)(config.endpoint, config.schemaFile);
        pm2Logs.cancel();
        if (started) {
            return async () => {
                pm2Debug(`\n***********************\nStopping supergraph...\n***********************\n\n`);
                await shutdownSupergraphUsingPm2();
            };
        }
        else {
            throw new Error('Supergraph did not start successfully');
        }
    }
    catch (err) {
        await shutdownSupergraphUsingPm2();
        throw err;
    }
}
/**
 * Flushes PM2 logs and then stops all PM2 processes (including daemon).
 */
async function shutdownSupergraphUsingPm2() {
    const logsFlushed = await (0, execa_1.default)('pm2', ['flush']);
    const stopped = await (0, execa_1.default)('pm2', ['kill']);
    if (logsFlushed.exitCode !== 0 || stopped.exitCode !== 0) {
        console.error('PM2 did not shutdown correctly');
    }
}
async function startProductsSubgraphUsingPm2(configFile) {
    // start products subgraph
    pm2Debug(`Starting products subgraph...`);
    const productsSubgraph = (0, execa_1.default)('pm2', ['start', configFile]);
    productsSubgraph.stdout.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
    productsSubgraph.stderr.pipe((0, logging_1.writeableDebugStream)(pm2Debug));
    return productsSubgraph;
}
async function startSupergraphUsingDocker(config) {
    await (0, composeSupergraph_1.composeSupergraph)(config.schemaFile, config.path ?? '', config.port ?? '4001');
    dockerDebug(`\n***********************\nStarting supergraph using Docker Compose...\n***********************\n\n`);
    const template = await (0, promises_1.readFile)((0, path_2.resolve)(__dirname, '../supergraph-compose.yaml.template'), 'utf-8');
    const supergraphConfig = template
        .replaceAll('${SCRIPT_DIR}', (0, path_1.normalizePath)((0, path_2.resolve)(__dirname, '..')))
        .replaceAll('${DIST_DIR}', (0, path_1.normalizePath)((0, path_2.resolve)(__dirname)));
    await (0, promises_1.writeFile)('supergraph-compose.yaml', supergraphConfig);
    try {
        const proc = (0, execa_1.default)('docker', [
            'compose',
            '-f',
            'supergraph-compose.yaml',
            '-f',
            config.composeFile,
            'up',
            '--build',
            '--detach',
        ]);
        proc.stdout.pipe((0, logging_1.writeableDebugStream)(dockerDebug));
        proc.stderr.pipe((0, logging_1.writeableDebugStream)(dockerDebug));
        await proc;
        if (proc.exitCode !== 0) {
            throw new Error('docker-compose did not start successfully');
        }
        const started = await (0, client_1.healthcheckSupergraph)(`http://localhost:${config.port ?? '4001'}${config.path ?? ''}`);
        if (started) {
            return async () => {
                dockerDebug(`\n***********************\nStopping supergraph...\n***********************\n\n`);
                await shutdownSupergraphUsingDocker(config.composeFile);
            };
        }
        else {
            throw new Error('Supergraph did not start successfully');
        }
    }
    catch (err) {
        await shutdownSupergraphUsingDocker(config.composeFile);
        throw err;
    }
}
async function shutdownSupergraphUsingDocker(composeFile) {
    const logs = (0, execa_1.default)('docker', [
        'compose',
        '-f',
        'supergraph-compose.yaml',
        '-f',
        composeFile,
        'logs',
    ]);
    logs.stdout.pipe((0, logging_1.writeableDebugStream)(dockerDebug));
    logs.stderr.pipe((0, logging_1.writeableDebugStream)(dockerDebug));
    const logsCompleted = await logs;
    const shutdown = await (0, execa_1.default)('docker', [
        'compose',
        '-f',
        'supergraph-compose.yaml',
        '-f',
        composeFile,
        'down',
        '--remove-orphans',
        '-v',
    ]);
    if (logsCompleted.exitCode !== 0 || shutdown.exitCode !== 0) {
        console.error('Docker compose did not shutdown correctly');
    }
}
//# sourceMappingURL=startSupergraph.js.map