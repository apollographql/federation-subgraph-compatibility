"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compatibilityTest = void 0;
const startSupergraph_1 = require("./startSupergraph");
const testRunner_1 = require("./testRunner");
const promises_1 = require("fs/promises");
const markdown_1 = require("./utils/markdown");
const logging_1 = require("./utils/logging");
async function compatibilityTest(runtimeConfig) {
    (0, logging_1.logWithTimestamp)('******************************************************');
    (0, logging_1.logWithTimestamp)('Starting Apollo Federation Subgraph Compatibility Test');
    (0, logging_1.logWithTimestamp)('******************************************************');
    const testResults = {};
    let allRequiredSuccessful = true;
    let allSuccessful = true;
    // start supergraph
    const stopSupergraph = await (0, startSupergraph_1.startSupergraph)(runtimeConfig);
    try {
        const productUrl = calculateProductSubgraphUrl(runtimeConfig);
        // run tests
        const { assertionPassed } = await (0, testRunner_1.runJest)(productUrl);
        for (const { assertion, required } of testRunner_1.TESTS) {
            const testSuccessful = assertionPassed(assertion);
            testResults[assertion] = { success: testSuccessful };
            if (!testSuccessful) {
                if (required) {
                    allRequiredSuccessful = false;
                    allSuccessful = false;
                }
                else {
                    allSuccessful = false;
                }
            }
        }
        (0, logging_1.logWithTimestamp)('compatibility tests complete...');
    }
    catch (err) {
        (0, logging_1.logWithTimestamp)(`compatibility tests encountered an error: ${err}`);
    }
    finally {
        await stopSupergraph();
    }
    (0, logging_1.logWithTimestamp)('generating results...');
    if (runtimeConfig.format == 'markdown') {
        (0, markdown_1.generateSimplifiedMarkdown)(testResults, `results.md`);
    }
    else {
        await (0, promises_1.writeFile)(`results.json`, JSON.stringify(testResults, null, 2), 'utf-8');
    }
    (0, logging_1.logWithTimestamp)('compatibility test complete');
    // print results to console
    (0, logging_1.logResults)(testResults);
    if (runtimeConfig.failOnWarning) {
        return allSuccessful;
    }
    else if (runtimeConfig.failOnRequired) {
        return allRequiredSuccessful;
    }
    else {
        return true;
    }
}
exports.compatibilityTest = compatibilityTest;
function calculateProductSubgraphUrl(config) {
    if (config.kind === 'pm2') {
        return config.endpoint;
    }
    else {
        const graphQLPath = config.path ?? '';
        const graphqlPort = config.port ?? '4001';
        return `http://localhost:${graphqlPort}${graphQLPath}`;
    }
}
//# sourceMappingURL=compatibilityTest.js.map