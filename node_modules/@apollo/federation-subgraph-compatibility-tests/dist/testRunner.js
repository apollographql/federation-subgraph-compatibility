"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runJest = exports.TESTS = void 0;
const execa_1 = __importDefault(require("execa"));
const debug_1 = __importDefault(require("debug"));
const path_1 = require("path");
const logging_1 = require("./utils/logging");
const jestDebug = (0, debug_1.default)('test');
exports.TESTS = [
    {
        assertion: 'introspection',
        column: '_service',
        fedVersion: 1,
        required: true,
    },
    {
        assertion: '@key single',
        column: '@key (single)',
        fedVersion: 1,
        required: true,
    },
    {
        assertion: '@key multiple',
        column: '@key (multi)',
        fedVersion: 1,
        required: false,
    },
    {
        assertion: '@key composite',
        column: '@key (composite)',
        fedVersion: 1,
        required: false,
    },
    {
        assertion: 'repeatable @key',
        column: 'repeatable @key',
        fedVersion: 1,
        required: false,
    },
    {
        assertion: '@requires',
        column: '@requires',
        fedVersion: 1,
        required: false,
    },
    {
        assertion: '@provides',
        column: '@provides',
        fedVersion: 1,
        required: false,
    },
    {
        assertion: 'ftv1',
        column: 'federated tracing',
        fedVersion: 1,
        required: false,
    },
    { assertion: '@link', column: '@link', fedVersion: 2, required: true },
    {
        assertion: '@shareable',
        column: '@shareable',
        fedVersion: 2,
        required: false,
    },
    { assertion: '@tag', column: '@tag', fedVersion: 2, required: false },
    {
        assertion: '@override',
        column: '@override',
        fedVersion: 2,
        required: false,
    },
    {
        assertion: '@inaccessible',
        column: '@inaccessible',
        fedVersion: 2,
        required: false,
    },
    {
        assertion: '@composeDirective',
        column: '@composeDirective',
        fedVersion: 2,
        required: false,
    },
    {
        assertion: '@interfaceObject',
        column: '@interfaceObject',
        fedVersion: 2,
        required: false,
    },
];
async function runJest(productsUrl) {
    (0, logging_1.infoLog)(new Date().toJSON(), 'starting tests...');
    jestDebug(`\n***********************\nStarting tests...\n***********************\n\n`);
    const jestBin = require.resolve('jest/bin/jest');
    const proc = (0, execa_1.default)(jestBin, [
        `${__dirname}/tests`,
        '--ci',
        '--json',
        '--config',
        (0, path_1.resolve)(__dirname, '../federation-jest.config.js'),
    ], {
        reject: false,
        env: { PRODUCTS_URL: productsUrl },
    });
    proc.stdout.pipe((0, logging_1.writeableDebugStream)(jestDebug));
    proc.stderr.pipe((0, logging_1.writeableDebugStream)(logging_1.infoLog));
    const { stdout, stderr } = await proc;
    if (proc.exitCode > 1) {
        throw new Error('jest failed to run');
    }
    const results = JSON.parse(stdout);
    const assertions = results.testResults.flatMap((x) => x.assertionResults);
    const assertionPassed = (name) => {
        return !assertions.some((a) => {
            const assertionName = a.ancestorTitles.length === 0 ? a.fullName : a.ancestorTitles[0];
            return assertionName === name && a.status === 'failed';
        });
    };
    return {
        rawResults: results,
        assertions,
        assertionPassed,
    };
}
exports.runJest = runJest;
//# sourceMappingURL=testRunner.js.map